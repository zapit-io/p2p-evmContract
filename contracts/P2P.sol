/**
   Licensed under the Apache License, Version 2.0 (the "License");
   you may not use this file except in compliance with the License.
   You may obtain a copy of the License at

      http://www.apache.org/licenses/LICENSE-2.0

   Unless required by applicable law or agreed to in writing, software
   distributed under the License is distributed on an "AS IS" BASIS,
   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
   See the License for the specific language governing permissions and
   limitations under the License.
*/
// SPDX-License-Identifier: Apache-2.0
pragma solidity ^0.8.18;

import "hardhat/console.sol";

/// @title Zapit P2P Escrows
/// @author Zapit
contract ZapitP2PEscrow {
    /***********************
    +   Global settings   +
    ***********************/

    // Address of the arbitrator
    address public arbitrator;
    // Address of the owner (who can withdraw collected fees)
    address public owner;

    uint8 public fees; // fees for zapit

    // Cumulative balance of collected fees
    uint256 public feesAvailableForWithdraw;

    /***********************
    +  Instruction types  +
    ***********************/

    // Called when the buyer marks payment as sent. Locks funds in escrow
    uint8 constant INSTRUCTION_SELLER_CANNOT_CANCEL = 0x01;
    // Buyer cancelling
    uint8 constant INSTRUCTION_BUYER_CANCEL = 0x02;
    // Seller cancelling
    uint8 constant INSTRUCTION_SELLER_CANCEL = 0x03;
    // Seller requesting to cancel. Begins a window for buyer to object
    uint8 constant INSTRUCTION_SELLER_REQUEST_CANCEL = 0x04;
    // Seller releasing funds to the buyer
    uint8 constant INSTRUCTION_RELEASE = 0x05;
    // Either party permitting the arbitrator to resolve a dispute
    uint8 constant INSTRUCTION_RESOLVE = 0x06;
    // custom order expiration option
    uint32 private ORDER_EXPIRATION = 4 hours;

    // Message to be signed by either of the parties for resolving a dispute
    bytes8 constant MESSAGE_DISPUTE = "ABCD";

    /***********************
    +       Events        +
    ***********************/

    event Created(bytes32 indexed _tradeHash);
    event SellerCancelDisabled(bytes32 indexed _tradeHash);
    event SellerRequestedCancel(bytes32 indexed _tradeHash);
    event CancelledBySeller(bytes32 indexed _tradeHash);
    event CancelledByBuyer(bytes32 indexed _tradeHash);
    event Released(bytes32 indexed _tradeHash);
    event DisputeResolved(bytes32 indexed _tradeHash);

    struct Escrow {
        // So we know the escrow exists
        bool exists;
        // This is the timestamp in whic the seller can cancel the escrow after.
        // It has two special values:
        // 0 : Permanently locked by the buyer (i.e. marked as paid; the seller can never cancel)
        // 1 : The seller can only request to cancel, which will change this value to a timestamp.
        //     This option is avaialble for complex trade terms such as cash-in-person where a
        //     payment window is inappropriate
        uint32 orderExpiration;
        // storing the timestamp when the escrow was created
        uint32 createdAt;
        // address of the buyer
        address payable _buyer;
        // address of the seller
        address payable _seller;
        // value of the escrow
        uint256 _value;
    }

    // Mapping of active trades. The key here is a hash of the trade proprties
    mapping(bytes32 => Escrow) public escrows;

    modifier onlyOwner() {
        require(msg.sender == owner, "Must be owner");
        _;
    }

    modifier matchInstruction(
        uint8 _instructionByte,
        uint8 _expectedInstruction
    ) {
        require(
            _instructionByte == _expectedInstruction,
            "Instruction byte doesn't match with the operation!"
        );
        _;
    }

    modifier onlyArbitrator() {
        require(msg.sender == arbitrator, "Must be arbitrator");
        _;
    }

    /// @notice Initialize the contract.
    constructor(uint8 _fees) {
        owner = msg.sender;
        arbitrator = msg.sender;
        fees = _fees; // stored in terms of basis-points
    }

    /// @notice Create and fund a new escrow.
    /// @param _tradeID The unique ID of the trade, generated by localethereum.com
    /// @param _seller The selling party
    /// @param _buyer The buying party
    /// @param _value The amount of the escrow, exclusive of the fee
    function createEscrow(
        bytes32 _tradeID,
        address _seller,
        address _buyer,
        uint256 _value
    ) external payable {
        // Require that trade does not already exist
        require(!escrows[_tradeID].exists, "Trade already exists");

        // Check transaction value against passed _value and make sure is not 0
        require(msg.value == _value && msg.value > 0, "Incorrect ETH sent");

        // Add the escrow to the public mapping
        escrows[_tradeID] = Escrow(
            true,
            ORDER_EXPIRATION,
            uint32(block.timestamp),
            payable(_buyer),
            payable(_seller),
            _value
        );
        emit Created(_tradeID);
    }

    /// @notice Called by the arbitrator to resolve a dispute. Requires a signature from either party.
    /// @param _tradeID Escrow "tradeID" parameter
    /// @param _sig Signature from either party
    /// @param signer Address of the signer
    /// @param _buyerPercent What % should be distributed to the buyer (this is usually 0 or 100)
    /// TBD
    function resolveDispute(
        bytes32 _tradeID,
        bytes memory _sig,
        address signer,
        uint8 _buyerPercent
    ) external onlyArbitrator {
        Escrow storage _escrow = escrows[_tradeID];
        require(_escrow.exists, "Escrow does not exist");
        bytes32 messageHash = keccak256(abi.encodePacked(MESSAGE_DISPUTE));

        messageHash = prefixed(messageHash);
        address _signature = recoverSigner(messageHash, _sig);

        console.log("Address", _signature);
        console.log("Escrow-seller", _escrow._seller);
        console.log("Signer", signer);

        require(
            _signature == _escrow._buyer || _signature == _escrow._seller,
            "Must be buyer or seller"
        );

        require(_buyerPercent <= 100, "_buyerPercent must be 100 or lower");

        uint256 _totalFees = (_escrow._value * fees) / 10000;

        feesAvailableForWithdraw += _totalFees;

        delete escrows[_tradeID];
        emit DisputeResolved(_tradeID);
        if (_buyerPercent == 100)
            payable(_escrow._buyer).transfer(
                ((_escrow._value - _totalFees) * _buyerPercent) / 100
            );
        if (_buyerPercent == 0)
            payable(_escrow._seller).transfer(
                ((_escrow._value - _totalFees) * (100 - _buyerPercent)) / 100
            );
    }

    /// @notice Withdraw fees collected by the contract. Only the owner can call this.
    /// @param _to Address to withdraw fees in to
    /// @param _amount Amount to withdraw
    function withdrawFees(
        address payable _to,
        uint256 _amount
    ) external onlyOwner {
        // This check also prevents underflow
        require(
            _amount <= feesAvailableForWithdraw,
            "Amount is higher than amount available"
        );
        feesAvailableForWithdraw -= _amount;
        payable(_to).transfer(_amount);
    }

    /// @notice Set the arbitrator to a new address. Only the owner can call this.
    /// @param _newArbitrator Address of the replacement arbitrator
    function setArbitrator(address _newArbitrator) external onlyOwner {
        arbitrator = _newArbitrator;
    }

    /// @notice Change the owner to a new address. Only the owner can call this.
    /// @param _newOwner Address of the replacement owner
    function setOwner(address _newOwner) external onlyOwner {
        owner = _newOwner;
    }

    ///@notice Called buy the buyer to cancel the escrow and returning the funds to the seller
    ///@param _tradeID Escrow "tradeID" parameter
    ///@param _instructionByte Instruction byte
    ///@return bool

    function buyerCancel(
        bytes32 _tradeID,
        uint8 _instructionByte
    )
        external
        matchInstruction(_instructionByte, INSTRUCTION_BUYER_CANCEL)
        returns (bool)
    {
        return doBuyerCancel(_tradeID);
    }

    /// @notice Transfer the value of an escrow, minus the fees
    /// @param _to Recipient address
    /// @param _value Value of the transfer

    function transferMinusFees(
        address payable _to,
        uint256 _value,
        uint32 _fee
    ) private {
        uint256 _totalFees = (_fee / 10000) * _value;
        if (_value - _totalFees > _value) return;
        // Add fees to the pot for zapit to withdraw (now it's 0)
        feesAvailableForWithdraw += _totalFees;
        payable(_to).transfer(_value);
    }

    /// @notice Change the order expiration time
    /// @param _newExpiration New expiration time
    function changeOrderExpiration(uint32 _newExpiration) external onlyOwner {
        ORDER_EXPIRATION = _newExpiration;
    }

    /// @notice Cancels the trade and returns the ETH to the seller. Can only be called the buyer.
    /// @param _tradeID Escrow "tradeID" parameter
    /// @return bool
    function doBuyerCancel(bytes32 _tradeID) private returns (bool) {
        Escrow storage _escrow = escrows[_tradeID];
        bytes32 _tradeHash;

        if (!_escrow.exists) return false;

        if (msg.sender != _escrow._buyer) return false;

        delete escrows[_tradeHash];

        emit CancelledByBuyer(_tradeID);
        transferMinusFees(_escrow._seller, _escrow._value, 0);
        return true;
    }

    /// @notice Recover the address of the signer of a message.
    /// @param message Message that was signed
    /// @param signature Signature from either party
    /// @return address

    function recoverSigner(
        bytes32 message,
        bytes memory signature
    ) internal pure returns (address) {
        bytes32 r;
        bytes32 s;
        uint8 v;

        assembly {
            r := mload(add(signature, 32))
            s := mload(add(signature, 64))
            v := byte(0, mload(add(signature, 96)))
        }

        if (v < 27) {
            v += 27;
        }

        require(v == 27 || v == 28);

        return ecrecover(message, v, r, s);
    }

    // Builds a prefixed hash to mimic the behavior of eth_sign.
    function prefixed(bytes32 hash) internal pure returns (bytes32) {
        return
            keccak256(
                abi.encodePacked("\x19Ethereum Signed Message:\n32", hash)
            );
    }

    function splitSignature(
        bytes memory sig
    ) internal pure returns (uint8 v, bytes32 r, bytes32 s) {
        require(sig.length == 65);
        assembly {
            // first 32 bytes, after the length prefix
            r := mload(add(sig, 32))
            // second 32 bytes
            s := mload(add(sig, 64))
            // final byte (first byte of the next 32 bytes)
            v := byte(0, mload(add(sig, 96)))
        }
    }
}
